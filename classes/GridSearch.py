from Datahandler import DataHandler
import matplotlib.pyplot as plt
import numpy as np
import itertools
from operator import itemgetter
import torch 
import pandas as pd

class GridSearch_PP_finder():
    def __init__(self, pp_grid, N_pop = 10000,version = "V2",device = "cuda" if torch.cuda.is_available() else "cpu", iterations = 120):
        '''
        parameters:
            pp_grid                 grid for pp search space 
            params_real             Paramters describing the real time series
            N_pop                   Number of individuals in the small world model
            version                 Version of the Small world model                
            device                  Device
            iterations              Number of iterations to find the optimal pandemic parameters
        '''
        self.pp_grid = pp_grid
        self.version = version
        self.device = device
        self.iterations = iterations

        self.simulation_parameters = {
            "N":N_pop,
            "d":14,
            "version":"V2" #TODO V3
        }

        # Print number of combinations 
        com = 1
        for x in self.pp_grid.values():
            com *= len(x)
        print(f"Number of combinations: {com}")

    def cost(self,ts_1,ts_2):
        '''
        returns the mean squared error between the two time series

        parameters:
            ts_1    first time series
            ts_2    second time series

        returns:
            mse
        '''

        mse = (ts_1 - ts_2)**2

        return torch.mean(mse)

    def get_time_series(self,mode,parameters):
        '''
        Get the time series used in the optimization and shape it as required

        parameters:
            mode:           Real or simulated data
            parameters:     parameters used to generate the time series
            device:         Device

        returns:
            ts:             Generated time serie
        '''

        #Get the full time series based on the observed cases
        DH_real = DataHandler(mode,parameters,device = self.device)
        ts,starting_points  = DH_real(B = None,L = None,return_plain=True)

        #Let the time series beginn with zero infected individuals
        ts = ts - ts[0]

        if mode == "Real":
            #remove constant values at the beginning, since these values can not be generated by the simulation
            mask = (ts != 0) 
            ts = ts[mask]
            ts = torch.cat((torch.zeros(1).to(self.device),ts))

        return ts

    def __call__(self,params_real, max_evals=200):

        #Get the real time series
        ts_real = self.get_time_series("Real", params_real)
 
        #Get the number of the time steps
        T = len(ts_real)

        # try all pp combinations
        keys, values = zip(*self.pp_grid.items())
        i = 0
        results = list()

        for v in itertools.product(*values):

            # Parse pp
            pp = dict(zip(keys, v))
            self.simulation_parameters['D'] = pp['D']
            self.simulation_parameters['r'] = pp['r']
            self.simulation_parameters['N_init'] = pp['N_init']
            self.simulation_parameters['T'] = T
            self.simulation_parameters['epsilon'] = pp['epsilon']

            #Get the simulated time series
            ts_simulation = self.get_time_series("Simulation", self.simulation_parameters)

            #Get the mse between the simulation and the real time series
            mse = self.cost(ts_real,ts_simulation)
            print(f"PP: {pp} | MSE = {mse}")

            #Append 
            results.append([pp,mse.cpu()])

            # Break if max_eval
            if i > max_evals:
                break
        

        # Sort by mse-loss
        results.sort(key=itemgetter(1), reverse=True)

        #Get the best parameters
        mse_list = [results[i][1] for i in range(len(results))] 
        index = np.argmin(mse_list)
        optimal_pp = results[index][0]

        #Get the time series for the best parameters
        self.simulation_parameters["D"] = int(optimal_pp['D'])
        self.simulation_parameters["r"] = optimal_pp['r']
        self.simulation_parameters["N_init"] = int(optimal_pp['N_init'])
        self.simulation_parameters["epsilon"] = optimal_pp['epsilon']
        ts_optimal = self.get_time_series("Simulation",self.simulation_parameters)
        
        #plot the best fitting simulation with observed data 
        plt.figure(figsize=(20,10))
        plt.plot(ts_optimal.cpu(),label = "simulation")
        plt.plot(ts_real.cpu(),label = "observation")
        country = params_real["file"].split(".")[0]
        plt.title(f"{country}, section {params_real['wave']}\n D = {self.simulation_parameters['D']}, r = {round(self.simulation_parameters['r'],4)}, N_init = {self.simulation_parameters['N_init']}, epsilon = {round(self.simulation_parameters['epsilon'],4)}")
        plt.legend()
        plt.savefig(f"./gridsearch/plots/GS_fit_{country}_{params_real['wave']}.jpg")
        plt.close()

        # save results
        df_results = pd.DataFrame(results)
        df_results.to_csv(f"./gridsearch/GS_fit_{country}_{params_real['wave']}.csv")

if __name__ == "__main__": 


    import json

    with open("./classes/Countries/wave_regions.json","r") as file:
        waves = json.load(file)

    for country in waves.keys():
        N = waves[country]["N_waves"]

        print(f"\n{country}")

        for i in range(N):
            print(f"\t{i+1} of {N}")

            params_real = {
                "file":f"{country}.txt",
                "wave":i+1,
                "full":False,
                "use_running_average":True,
                "dt_running_average":14
            }

            pp_grid = {
                "epsilon": [0.1],
                "D": [5], #[5,6,7,8,9,10,15,20], #list(np.linspace(5,10,6)), #[5,10], #list(np.linspace(5,10,6)),
                "r": [0.02], #[0.01, 0.02, 0.05, 0.1, 0.15, 0.2], #list(np.linspace(5,10,6)), #[0.05], #list(np.linspace(0.05,0.2,4)),
                "d": [14], #[5], #list(np.linspace(5,10,6)),
                "N_init": [5]# [5,10,15,20,30,40,50,60,70,80,90,100]
            }

            gs = GridSearch_PP_finder(pp_grid=pp_grid, iterations = 60)
            gs(params_real)

            #gp = GP_PP_finder(N_initial_PP_samples = 60,iterations = 60)
            #gp(params_real)
    
    '''
    params_real = {
        "file":"Israel.txt",
        "wave":3,
        "full":False,
        "use_running_average":True,
        "dt_running_average":14
    }

    pp_grid = {
        "epsilon": [0.1],
        "D": [5,10], #list(np.linspace(5,10,6)),
        "r": [0.05], #list(np.linspace(0.01,0.2,)),
        "d": [5], #list(np.linspace(5,10,6)),
        "N_init": [5,10,15]
    }

    gs = GridSearch_PP_finder(pp_grid=pp_grid, iterations = 100)
    gs(params_real)
    '''