from torch._C import parse_schema
from Datahandler import DataHandler
import matplotlib.pyplot as plt
import sobol_seq
import numpy as np
import GPy
import scipy
import optunity
import itertools
from operator import itemgetter
import torch 

class GridSearch_PP_finder():
    def __init__(self, pp_grid, N_pop = 1000,version = "V3",device = "cuda" if torch.cuda.is_available() else "cpu", iterations = 120):
        '''
        parameters:
            pp_grid                 grid for pp search space 
            params_real             Paramters describing the real time series
            N_pop                   Number of individuals in the small world model
            version                 Version of the Small world model                
            device                  Device
            iterations              Number of iterations to find the optimal pandemic parameters
        '''
        self.pp_grid = pp_grid
        self.version = version
        self.device = device
        self.iterations = iterations

        self.simulation_parameters = {
            "N":N_pop,
            "d":14,
            "version":"V2" #TODO V3
        }

        # Print number of combinations 
        com = 1
        for x in self.pp_grid.values():
            com *= len(x)
        print(f"Number of combinations: {com}")

    def cost(self,ts_1,ts_2):
        '''
        returns the mean squared error between the two time series

        parameters:
            ts_1    first time series
            ts_2    second time series

        returns:
            mse
        '''

        mse = (ts_1 - ts_2)**2

        return np.mean(mse)

    def get_time_series(self,mode,parameters,device = "cpu"):
        '''
        Get the time series used in the optimization and shape it as required

        parameters:
            mode:           Real or simulated data
            parameters:     parameters used to generate the time series
            device:         Device

        returns:
            ts:             Generated time serie
        '''

        #Get the full time series based on the observed cases
        DH_real = DataHandler(mode,parameters,device = device)
        ts,starting_points  = DH_real(B = None,L = None,return_plain=True)

        #Let the time series beginn with zero infected individuals
        ts = ts - ts[0]

        if mode == "Real":
            #remove constant values at the beginning, since these values can not be generated by the simulation
            mask = (ts != 0) 
            ts = ts[mask]
            ts = np.concatenate((np.zeros(1),ts))

        return ts

    def __call__(self,params_real, max_evals=200):

        #Get the real time series
        ts_real = self.get_time_series("Real", params_real,device = "cpu")
 
        #Get the number of the time steps
        T = len(ts_real)

        # try all pp combinations
        keys, values = zip(*self.pp_grid.items())
        i = 0
        results = list()

        for v in itertools.product(*values):

            # Parse pp
            pp = dict(zip(keys, v))
            self.simulation_parameters['D'] = pp['D']
            self.simulation_parameters['r'] = pp['r']
            self.simulation_parameters['N_init'] = pp['N_init']
            self.simulation_parameters['T'] = T
            self.simulation_parameters['epsilon'] = pp['epsilon']

            #Get the simulated time series
            ts_simulation = self.get_time_series("Simulation", self.simulation_parameters,device = "cpu")

            #Get the mse between the simulation and the real time series
            mse = self.cost(ts_real,ts_simulation)
            print(f"PP: {pp} | MSE = {mse}")

            #Append 
            results.append([pp,mse])

            # Break if max_eval
            if i > max_evals:
                break
        

        # Sort by mse-loss
        results.sort(key=itemgetter(1), reverse=True)

        #Get the best parameters
        mse_list = [results[i][1] for i in range(len(results))] 
        index = np.argmin(mse_list)
        optimal_pp = results[index][0]

        #Get the time series for the best parameters
        self.simulation_parameters["D"] = int(optimal_pp['D'])
        self.simulation_parameters["r"] = optimal_pp['r']
        self.simulation_parameters["N_init"] = int(optimal_pp['N_init'])
        self.simulation_parameters["epsilon"] = optimal_pp['epsilon']
        ts_optimal = self.get_time_series("Simulation",self.simulation_parameters,device = "cpu")
        
        #plot the best fitting simulation with observed data 
        plt.figure(figsize=(20,10))
        plt.plot(ts_optimal,label = "simulation")
        plt.plot(ts_real,label = "observation")
        country = params_real["file"].split(".")[0]
        plt.title(f"{country}, section {params_real['wave']}\n D = {self.simulation_parameters['D']}, r = {round(self.simulation_parameters['r'],4)}, N_init = {self.simulation_parameters['N_init']}, epsilon = {round(self.simulation_parameters['epsilon'],4)}")
        plt.legend()
        plt.savefig(f"./plots/GS_fit_{country}_{params_real['wave']}.jpg")
        plt.close()

if __name__ == "__main__": 
    
    params_real = {
        "file":"Israel.txt",
        "wave":3,
        "full":False,
        "use_running_average":True,
        "dt_running_average":14
    }

    pp_grid = {
        "epsilon": [0.1],
        "D": [5,10], #list(np.linspace(5,10,6)),
        "r": [0.05], #list(np.linspace(0.05,0.2,4)),
        "d": [5], #list(np.linspace(5,10,6)),
        "N_init": [5,10,15]
    }

    gs = GridSearch_PP_finder(pp_grid=pp_grid, iterations = 100)
    gs(params_real)