import copy
from Datahandler import DataHandler
import matplotlib.pyplot as plt
import numpy as np
import itertools
from operator import itemgetter
import torch
import random
import pandas as pd
import time

class GridSearch_PP_finder():
    def __init__(self, pp_grid, eval_num = 10, N_pop = 1000, version = "V2",device = "cuda" if torch.cuda.is_available() else "cpu", mode="random"):
        '''
        parameters:
            pp_grid                 grid for pp search space with epsilon D,r,d,N_init
            params_real             Paramters describing the real time series
            N_pop                   Number of individuals in the small world model
            version                 Version of the Small world model                
            device                  Device
            mode                    if "random" -> sample pps in intervals specified in pp_grid
                                    if "full_grid" -> use cartesian product of pp specified in pp_grid
        '''
        assert all(key in pp_grid for key in ['epsilon','d','D','r','N_init'])
        self.mode = mode
        self.eval_num = eval_num
        self.pp_grid = pp_grid
        self.version = version
        self.device = device
        self.simulation_parameters = {
            "N":N_pop,
            "version": version
        }

        # Print number of combinations 
        com = 1
        for x in self.pp_grid.values():
            com *= len(x)
        print(f"Number of possible combinations: {com}")

    def cost(self,ts_1,ts_2):
        '''
        returns the mean squared error between the two time series

        parameters:
            ts_1    first time series
            ts_2    second time series

        returns:
            mse
        '''

        mse = (ts_1 - ts_2)**2

        return torch.mean(mse)

    def get_time_series(self,mode,parameters):
        '''
        Get the time series used in the optimization and shape it as required

        parameters:
            mode:           Real or simulated data
            parameters:     parameters used to generate the time series
            device:         Device

        returns:
            ts:             Generated time serie
        '''

        #Get the full time series based on the observed cases
        DH = DataHandler(mode,parameters,device = self.device)
        ts,starting_points  = DH(B = None,L = None,return_plain=True)

        if mode == "Real":
            #remove constant values at the beginning, since these values can not be generated by the simulation
            mask = (ts != 0) 
            ts = ts[mask]
            ts = torch.cat((torch.zeros(1).to(self.device),ts))

        return ts

    def __call__(self,params_real):

        #Get the real time series
        ts_real = self.get_time_series("Real", params_real)
 
        #Get the number of time steps
        T = len(ts_real)

        # try all pp combinations
        keys, values = zip(*self.pp_grid.items())
        pp_combinations = list(itertools.product(*values))

        if(self.mode == "random"):
            pp_combinations = random.sample(pp_combinations,self.eval_num)

        i = 0
        results = list()
        print(f"Number of evaluated combinations: {len(pp_combinations)}")

        for v in pp_combinations:

            print(i)
            i+= 1

            # Measure time 
            t0 = time.perf_counter()

            # Parse pp
            pp = dict(zip(keys, v))
            self.simulation_parameters['d'] = pp['d']
            self.simulation_parameters['D'] = pp['D']
            self.simulation_parameters['r'] = pp['r']
            self.simulation_parameters['r_new'] = pp["r_new"]
            self.simulation_parameters['D_new'] = pp["D_new"]
            self.simulation_parameters['T_change_D'] = pp["T_change_D"]
            self.simulation_parameters['Smooth_transition'] = pp["Smooth_transition"]

            self.simulation_parameters['N_init'] = pp['N_init']
            self.simulation_parameters['T'] = T
            self.simulation_parameters['epsilon'] = pp['epsilon']

            # Without changing D 
            self.simulation_parameters["T_change_D"] = T  

            #Get the simulated time series
            ts_simulation = self.get_time_series("Simulation", self.simulation_parameters)

            t1 = time.perf_counter()

            #Get the mse between the simulation and the real time series
            mse = self.cost(ts_real,ts_simulation)
            print(f"PP: {pp} | MSE = {mse} | Time = {t1-t0}")

            #Append 
            current_simulation_parameters = copy.deepcopy(self.simulation_parameters)
            results.append([current_simulation_parameters, float(mse.cpu().numpy())])

            # Break if max_eval
            if i > self.max_evals:
                break
    
        # Sort by mse-loss
        results.sort(key=itemgetter(1), reverse=False)

        #Get the best parameters
        mse_list = [results[i][1] for i in range(len(results))] 
        index = np.argmin(mse_list)
        optimal_pp = results[index][0]

        #Get the time series for the best parameters
        self.simulation_parameters["D"] = int(optimal_pp['D'])
        self.simulation_parameters["D_new"] = int(optimal_pp["D_new"])
        self.simulation_parameters["r"] = optimal_pp['r']
        self.simulation_parameters["r_new"] = optimal_pp["r_new"]

        self.simulation_parameters['T_change_D'] = int(pp["T_change_D"])
        self.simulation_parameters['Smooth_transition'] = int(pp["Smooth_transition"])

        self.simulation_parameters["N_init"] = int(optimal_pp['N_init'])
        self.simulation_parameters["epsilon"] = optimal_pp['epsilon']
        ts_optimal = self.get_time_series("Simulation",self.simulation_parameters)
        
        #plot the best fitting simulation with observed data 
        plt.figure(figsize=(20,10))
        plt.plot(ts_optimal.cpu(),label = "simulation")
        plt.plot(ts_real.cpu(),label = "observation")
        country = params_real["file"].split(".")[0]
        plt.title(f"{country}, section {params_real['wave']}\n D = {self.simulation_parameters['D']}, r = {round(self.simulation_parameters['r'],4)}, N_init = {self.simulation_parameters['N_init']}, epsilon = {round(self.simulation_parameters['epsilon'],4)}, d = {round(self.simulation_parameters['d'],4)}, version = {self.simulation_parameters['version']}, N = {round(self.simulation_parameters['N'],4)}")
        plt.legend()
        plt.savefig(f"./gridsearch/plots/GS_fit_{country}_{params_real['wave']}.jpg")
        plt.close()

        # save results to disk
        df_results = pd.DataFrame(results)
        df_results.to_csv(f"./gridsearch/GS_fit_{country}_{params_real['wave']}.csv") 

if __name__ == "__main__": 


    import json

    N_pop = 2500
    simulation_version = 'V2'
    eval_num = 1500
    mode =  "random" #"full_grid"

    with open("./classes/Countries/wave_regions.json","r") as file:
        waves = json.load(file)
    countries = waves.keys()
    countries = ["UnitedStates", "Israel", "UnitedKingdom"] #["Germany", "Sweden", "UnitedStates", "Israel", "UnitedKingdom"]

    for country in countries: 
        N = waves[country]["N_waves"]

        print(f"\n{country}")

        for i in range(N):
            print(f"\t{i+1} of {N}")

            params_real = {
                "file":f"{country}.txt",
                "wave":i+1,
                "full":False,
                "use_running_average":True,
                "dt_running_average":14
            }

            pp_grid_old = {
                "epsilon": [0.1],
                "D": [5,8,10,15,20], # [5], list(np.linspace(5,10,6)), #[5,10], #list(np.linspace(5,10,6)),
                "r": [0.01, 0.02, 0.05, 0.1, 0.15, 0.2], #[0.02], # #list(np.linspace(5,10,6)), #[0.05], #list(np.linspace(0.05,0.2,4)),
                "d": list(np.linspace(5,10,6)),
                "N_init": [5,10,20,50,80,100]
            }

            pp_grid_reduced = {
                "epsilon": [0.01,0.05,0.1],
                "D": [1,2,3,4,5,6,7,8,9,10], #[5,8,10,15,20], # [5], list(np.linspace(5,10,6)), #[5,10], #list(np.linspace(5,10,6)),
                "D_new": [1,2,3,4,5,6,7,8,9,10],
                "r": [0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1], #[0.01, 0.02, 0.05, 0.1, 0.15, 0.2], #[0.02], # #list(np.linspace(5,10,6)), #[0.05], #list(np.linspace(0.05,0.2,4)),
                "r_new": [0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1],
                "d": list(np.linspace(5,6,7)),
                "N_init": [1,2,3,4,5,6,7,8,9,10], # 20,50,80,100]
                "T_change_D":[10,15,20,25,30],
                "Smooth_transition":[1e4]
            }

            pp_grid = {
                "epsilon": list(np.linspace(0.05,0.2, 4)), #[0.1],
                "D": list(np.linspace(5,10,6,dtype=int)), # [5,8,10,15,20], # [5], list(np.linspace(5,10,6)), #[5,10], #list(np.linspace(5,10,6)),
                "r": list(np.linspace(0.01,0.2,20)), #[0.01, 0.02, 0.05, 0.1, 0.15, 0.2], #[0.02], # #list(np.linspace(0.01,0.2,19)), #[0.05], #list(np.linspace(0.05,0.2,4)),
                "d": list(np.linspace(5,10,6,dtype=int)),
                "N_init": list(np.linspace(5,100,20,dtype=int)) #[5,10,20,50,80,100]
            }

            gs = GridSearch_PP_finder(pp_grid=pp_grid_reduced, N_pop=N_pop, eval_num=eval_num, mode=mode, version=simulation_version, device="cpu")
            gs(params_real)

            #gp = GP_PP_finder(N_initial_PP_samples = 60,iterations = 60)
            #gp(params_real)
    
    '''
    params_real = {
        "file":"Israel.txt",
        "wave":3,
        "full":False,
        "use_running_average":True,
        "dt_running_average":14
    }

    pp_grid = {
        "epsilon": [0.1],
        "D": [5,10], #list(np.linspace(5,10,6)),
        "r": [0.05], #list(np.linspace(0.01,0.2,)),
        "d": [5], #list(np.linspace(5,10,6)),
        "N_init": [5,10,15]
    }

    gs = GridSearch_PP_finder(pp_grid=pp_grid, iterations = 100)
    gs(params_real)
    '''